#!/bin/sh

# Script configuration and variables
DEFAULT_PORT=3000
DOCKER_STOP_TIMEOUT=0
PROJECT_NAME=$(basename "$PWD")

# Determine container name and image based on presence of local Dockerfile.devbox
if [ -f "Dockerfile.devbox" ]; then
  CONTAINER_NAME="devbox-$PROJECT_NAME"
  IMAGE_NAME="devbox-$PROJECT_NAME"
else
  CONTAINER_NAME="$PROJECT_NAME-devbox"
  IMAGE_NAME="devbox"
fi

get_script_directory() {
  local script_path="$0"
  while [ -L "$script_path" ]; do
    script_path="$(readlink "$script_path")"
  done
  cd "$(dirname "$script_path")" && pwd
}

get_dockerfile_path() {
  if [ -f "Dockerfile.devbox" ]; then
    echo "$PWD/Dockerfile.devbox"
  else
    echo "$(get_script_directory)/Dockerfile.devbox"
  fi
}

# Colors and printing functions
RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BLUE='\033[34m'
MAGENTA='\033[35m'
CYAN='\033[36m'
WHITE='\033[37m'
GRAY='\033[90m'
BLACK='\033[0m'

print_error() {
  echo "${RED}Error: $1${BLACK}"
}

print_success() {
  echo "âœ… $1"
}

# Prerequisites check
ensure_docker() {
  # Check if docker command exists
  if ! command -v docker >/dev/null; then
    print_error "Docker is not installed."
    echo "Please install Docker: brew install docker"
    return 1
  fi

  # Check if orb command exists (for OrbStack)
  if ! command -v orb >/dev/null; then
    print_error "OrbStack is not installed."
    echo "Please install OrbStack: brew install orbstack"
    return 1
  fi

  # Check if OrbStack is running
  if ! orb status >/dev/null; then
    orb start
    echo "OrbStack started successfully."
  fi

  # Check if Docker daemon is accessible
  if ! docker info >/dev/null; then
    print_error "Docker daemon is not accessible."
    echo "Please ensure Docker/OrbStack is running properly."
    return 1
  fi

  return 0
}

ensure_dockerfile() {
  local dockerfile_path
  dockerfile_path=$(get_dockerfile_path)

  if [ ! -f "$dockerfile_path" ]; then
    print_error "Dockerfile not found at $dockerfile_path"
    return 1
  fi

  return 0
}

# Docker image functions
image_exists() {
  docker image inspect "$IMAGE_NAME" >/dev/null
}

get_dockerfile_hash() {
  local dockerfile_path="$1"
  if [ -f "$dockerfile_path" ]; then
    shasum -a 256 "$dockerfile_path" | cut -d' ' -f1
  else
    echo ""
  fi
}

get_image_dockerfile_hash() {
  docker image inspect "$IMAGE_NAME" --format '{{index .Config.Labels "dockerfile.hash"}}' 2>/dev/null || echo ""
}

needs_rebuild() {
  local dockerfile_path
  dockerfile_path=$(get_dockerfile_path)

  # Check if image exists
  if ! image_exists; then
    return 0  # Image doesn't exist, needs build
  fi

  # Get current Dockerfile hash and stored hash
  local current_hash stored_hash
  current_hash=$(get_dockerfile_hash "$dockerfile_path")
  stored_hash=$(get_image_dockerfile_hash)

  # If we can't get hashes or they don't match, rebuild needed
  if [ -z "$current_hash" ] || [ -z "$stored_hash" ] || [ "$current_hash" != "$stored_hash" ]; then
    return 0  # Dockerfile content has changed, needs rebuild
  fi

  return 1  # No rebuild needed
}

build_image() {
  local dockerfile_path
  dockerfile_path=$(get_dockerfile_path)

  # Get Dockerfile hash to store as label
  local dockerfile_hash
  dockerfile_hash=$(get_dockerfile_hash "$dockerfile_path")

  echo "Building Docker image '$IMAGE_NAME'..."
  if [ -f "Dockerfile.devbox" ]; then
    # Project-specific build from current directory
    if ! docker build -f "$dockerfile_path" -t "$IMAGE_NAME" --label "dockerfile.hash=$dockerfile_hash" .; then
      print_error "Failed to build Docker image."
      return 1
    fi
  else
    # Default build from devbox repo directory
    local script_dir
    script_dir=$(get_script_directory)
    if ! docker build -f "$dockerfile_path" -t "$IMAGE_NAME" --label "dockerfile.hash=$dockerfile_hash" "$script_dir"; then
      print_error "Failed to build Docker image."
      return 1
    fi
  fi

  print_success "Successfully built $IMAGE_NAME image."
  return 0
}

ensure_image() {
  local dockerfile_path
  dockerfile_path=$(get_dockerfile_path)

  if [ -f "Dockerfile.devbox" ]; then
    # Project-specific container: local Dockerfile exists
    :  # no-op, file exists
  else
    # Default container: check for devbox Dockerfile in script directory
    if [ ! -f "$dockerfile_path" ]; then
      print_error "Default Dockerfile.devbox not found at $dockerfile_path"
      echo "Please ensure devbox is properly installed."
      return 1
    fi
  fi

  # Check if image exists and is current
  if ! docker image inspect "$IMAGE_NAME" >/dev/null; then
    echo "Docker image '$IMAGE_NAME' not found. Building image..."
    build_image
  elif needs_rebuild; then
    echo "Dockerfile has been modified. Rebuilding image..."
    build_image
  fi

  return 0
}

# Docker container functions
container_exists() {
  docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"
}

container_is_running() {
  [ "$(docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null)" = "true" ]
}

create_container() {
  local port="${PORT:-$DEFAULT_PORT}"
  echo "Creating new container $CONTAINER_NAME..."

  # Load devbox config based on which container type we're using
  local script_dir
  script_dir=$(get_script_directory)

  if [ -f "Dockerfile.devbox" ]; then
    # Project-specific container: only load local devbox.env if it exists
    if [ -f "devbox.env" ]; then
      . ./devbox.env
    fi
  else
    # Default container: only load devbox repo devbox.env if it exists
    if [ -f "$script_dir/devbox.env" ]; then
      . "$script_dir/devbox.env"
    fi
  fi

  # Parse DEVBOX_CONFIG for additional docker run options
  local config_options=""
  if [ -n "$DEVBOX_CONFIG" ]; then
    config_options="$DEVBOX_CONFIG"
  fi

  docker run -d -p "$port:$port" -e "PORT=$port" --name "$CONTAINER_NAME" \
    -v "$PWD":"/root/$PROJECT_NAME" $config_options "$IMAGE_NAME" tail -f /dev/null
}

ensure_container() {
  if container_exists; then
    if ! container_is_running; then
      echo "Starting stopped container $CONTAINER_NAME..."
      docker start "$CONTAINER_NAME"
    else
      echo "Container $CONTAINER_NAME is already running."
    fi
  else
    create_container
  fi
}

# Cleanup and delete functions
stop_container() {
  if container_exists; then
    echo "Stopping and deleting container $CONTAINER_NAME..."
    docker stop -t "$DOCKER_STOP_TIMEOUT" "$CONTAINER_NAME" >/dev/null || true
    docker rm "$CONTAINER_NAME" >/dev/null
  else
    echo "Container $CONTAINER_NAME does not exist."
  fi
}

delete_image() {
  # Delete the image if it exists
  if image_exists; then
    echo "Deleting Docker image '$IMAGE_NAME'..."
    if docker rmi "$IMAGE_NAME" 2>/dev/null; then
      print_success "Successfully deleted image '$IMAGE_NAME'"
    else
      print_error "Failed to delete image '$IMAGE_NAME'"
      return 1
    fi
  else
    echo "Docker image '$IMAGE_NAME' does not exist."
  fi
}


attach_container() {
  # Attach to the container
  docker exec -it -w "/root/$PROJECT_NAME" "$CONTAINER_NAME" /bin/zsh
}

auto_stop() {
  # Check if container exists
  if ! container_exists; then
    return 0
  fi

  # If container exists but isn't running, delete it
  if ! container_is_running; then
    echo "Container is stopped. Deleting container..."
    docker rm "$CONTAINER_NAME"
    return 0
  fi

  # Count the number of attached shells (processes running /bin/zsh)
  local shell_count
  shell_count=$(docker exec "$CONTAINER_NAME" ps aux | grep -c "/bin/zsh" 2>/dev/null || echo "0")

  # Ensure shell_count is a valid integer
  case "$shell_count" in
    ''|*[!0-9]*) shell_count=0 ;;
  esac

  # If no shells are attached, stop the container
  if [ "$shell_count" -eq 0 ]; then
    stop_container
  fi
}

stop_all_containers() {
  # Get all running devbox containers
  local devbox_containers
  devbox_containers=$(docker ps --filter "name=-devbox" --filter "name=devbox-" --format "{{.Names}}")

  if [ -z "$devbox_containers" ]; then
    return 0
  fi

  echo "$devbox_containers" | while read -r container; do
    echo "Stopping and removing container: $container"
    docker stop -t "$DOCKER_STOP_TIMEOUT" "$container" >/dev/null || true
    docker rm "$container" >/dev/null || true
  done
}

auto_off() {
  # Check if any devbox containers are running
  local running_devbox_containers
  running_devbox_containers=$(docker ps --filter "name=-devbox" --filter "name=devbox-" -q | wc -l | tr -d ' ')

  # If no devbox containers are running, stop OrbStack
  if [ "$running_devbox_containers" -eq 0 ]; then
    orb stop
    echo "OrbStack stopped."
  fi
}

init_devbox() {
  if [ -f "Dockerfile.devbox" ]; then
    echo "Dockerfile.devbox already exists in current directory."
    echo "Remove it first if you want to reinitialize."
    return 1
  fi

  local script_dir dockerfile_template env_template
  script_dir=$(get_script_directory)
  dockerfile_template="$script_dir/Dockerfile.devbox"
  env_template="$script_dir/devbox.env"

  # Copy Dockerfile template
  if [ -f "$dockerfile_template" ]; then
    cp "$dockerfile_template" "./Dockerfile.devbox"
    echo "Created Dockerfile.devbox from template in current directory."
  else
    print_error "Dockerfile.devbox not found in devbox installation directory."
    echo "Please ensure devbox is properly installed."
    return 1
  fi

  # Copy devbox.env template if it doesn't exist
  if [ -f "$env_template" ] && [ ! -f "devbox.env" ]; then
    cp "$env_template" "./devbox.env"
    echo "Created devbox.env configuration file."
  fi

  echo "Edit the Dockerfile.devbox to customize tools for your project."
  echo "Edit the devbox.env to customize container options (volumes, env vars, etc)."
}

show_status() {
  local dockerfile_path
  dockerfile_path=$(get_dockerfile_path)

  echo "$PROJECT_NAME"
  printf "  Dockerfile: %s\n" "$dockerfile_path"

  # Check if image exists and determine status
  if ! image_exists; then
    printf "  Image:       %s " "$IMAGE_NAME"
    printf "${YELLOW}[NOT BUILT]${BLACK}\n"
  else
    printf "  Image:       %s " "$IMAGE_NAME"
    # Check if rebuild is needed
    if needs_rebuild; then
      printf "${YELLOW}[REBUILD NEEDED]${BLACK}\n"
    else
      printf "${GREEN}[UP TO DATE]${BLACK}\n"
    fi
  fi

  # Check container status
  printf "  Container:   %s " "$CONTAINER_NAME"
  if container_exists; then
    if container_is_running; then
      printf "${GREEN}[RUNNING]${BLACK}\n"
    else
      printf "${YELLOW}[STOPPED]${BLACK}\n"
    fi
  else
    printf "${YELLOW}[NOT CREATED]${BLACK}\n"
  fi
}

# Check the command argument
case "$1" in
  init)
    init_devbox
    ;;
  status)
    if ! ensure_docker; then exit 1; fi
    show_status
    ;;
  build)
    if ! ensure_docker; then exit 1; fi
    if ! ensure_dockerfile; then exit 1; fi
    build_image
    ;;
  delete)
    if ! ensure_docker; then exit 1; fi
    if ! ensure_dockerfile; then exit 1; fi
    delete_devbox
    ;;
  start)
    if ! ensure_docker; then exit 1; fi
    if ! ensure_dockerfile; then exit 1; fi
    if ! ensure_image; then exit 1; fi
    ensure_container
    ;;
  stop)
    if ! ensure_docker; then exit 1; fi
    if ! ensure_dockerfile; then exit 1; fi
    stop_container
    ;;
  off)
    if ! ensure_docker; then exit 1; fi
    stop_all_containers
    auto_off
    ;;
  "")
    if ! ensure_docker; then exit 1; fi
    if ! ensure_dockerfile; then exit 1; fi
    if ! ensure_image; then exit 1; fi
    if ! ensure_container; then exit 1; fi
    attach_container
    auto_stop
    auto_off
    ;;
  help|--help|-h|*)
    echo "Usage: $0 [COMMAND]"
    echo ""
    echo "Commands:"
    echo "  (no args)  - Create the devbox and attach to it."
    echo "  status     - Show status of devbox Dockerfile, image, and container."
    echo "  init       - Copy Dockerfile.devbox template to current directory for a project-specific devbox."
    echo "  delete     - Stop the container, delete it, and delete the image."
    echo "  stop       - Stop the container and delete the container."
    echo "  off        - Force stop all devbox containers and stop OrbStack."
    ;;
esac
