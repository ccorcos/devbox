#!/bin/sh

# Color variables for output formatting
RED='\033[31m'
GREEN='\033[32m'
YELLOW='\033[33m'
BLUE='\033[34m'
MAGENTA='\033[35m'
CYAN='\033[36m'
WHITE='\033[37m'
GRAY='\033[90m'
BLACK='\033[0m'

# Get the name of the current directory and assign it to X
PROJECT_NAME=$(basename "$PWD")

# Determine container name and image based on presence of local Dockerfile.devbox
if [ -f "Dockerfile.devbox" ]; then
  CONTAINER_NAME="devbox-$PROJECT_NAME"
  IMAGE_NAME="devbox-$PROJECT_NAME"
  DOCKERFILE_PATH="Dockerfile.devbox"
else
  CONTAINER_NAME="$PROJECT_NAME"
  IMAGE_NAME="devbox"
  DOCKERFILE_PATH=""
fi

# Function to check prerequisites
check_prerequisites() {
  # Check if docker command exists
  if ! command -v docker >/dev/null 2>&1; then
    echo "${RED}Error: Docker is not installed.${BLACK}"
    echo "Please install Docker: brew install docker"
    return 1
  fi

  # Check if orb command exists (for OrbStack)
  if ! command -v orb >/dev/null 2>&1; then
    echo "${RED}Error: OrbStack is not installed.${BLACK}"
    echo "Please install OrbStack: brew install orbstack"
    return 1
  fi

  # Check if OrbStack is running
  if ! orb status >/dev/null 2>&1; then
    echo "OrbStack is not running. Starting OrbStack..."
    orb start
    # Wait a moment for OrbStack to start
    # sleep 3
    echo "✅ OrbStack started successfully."
  fi

  # Check if Docker daemon is accessible
  if ! docker info >/dev/null 2>&1; then
    echo "${RED}Error: Docker daemon is not accessible.${BLACK}"
    echo "Please ensure Docker/OrbStack is running properly."
    return 1
  fi

  return 0
}

# Function to get the path to the Dockerfile being used
get_dockerfile_path() {
  if [ -n "$DOCKERFILE_PATH" ]; then
    echo "$PWD/$DOCKERFILE_PATH"
  else
    # Get the directory of the devbox script (resolve symlinks)
    SCRIPT_PATH="$0"
    while [ -L "$SCRIPT_PATH" ]; do
      SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    done
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
    echo "$SCRIPT_DIR/Dockerfile.devbox"
  fi
}

# Function to get the hash of the Dockerfile content
get_dockerfile_hash() {
  local dockerfile_path="$1"
  if [ -f "$dockerfile_path" ]; then
    shasum -a 256 "$dockerfile_path" | cut -d' ' -f1
  else
    echo ""
  fi
}

# Function to get the stored hash for the image
get_image_dockerfile_hash() {
  docker image inspect "$IMAGE_NAME" --format '{{index .Config.Labels "dockerfile.hash"}}' 2>/dev/null || echo ""
}

# Function to check if image needs rebuilding
needs_rebuild() {
  local dockerfile_path
  dockerfile_path=$(get_dockerfile_path)

  # Check if image exists
  if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
    return 0  # Image doesn't exist, needs build
  fi

  # Check if Dockerfile exists
  if [ ! -f "$dockerfile_path" ]; then
    return 1  # No Dockerfile, can't rebuild
  fi

  # Get current Dockerfile hash and stored hash
  local current_hash stored_hash
  current_hash=$(get_dockerfile_hash "$dockerfile_path")
  stored_hash=$(get_image_dockerfile_hash)

  # If we can't get hashes or they don't match, rebuild needed
  if [ -z "$current_hash" ] || [ -z "$stored_hash" ] || [ "$current_hash" != "$stored_hash" ]; then
    return 0  # Dockerfile content has changed, needs rebuild
  fi

  return 1  # No rebuild needed
}

# Function to build the Docker image
build_image() {
  local dockerfile_path
  dockerfile_path=$(get_dockerfile_path)

  if [ ! -f "$dockerfile_path" ]; then
    echo "${RED}Error: Dockerfile not found at $dockerfile_path${BLACK}"
    return 1
  fi

  # Get Dockerfile hash to store as label
  local dockerfile_hash
  dockerfile_hash=$(get_dockerfile_hash "$dockerfile_path")

  echo "Building Docker image '$IMAGE_NAME'..."
  if [ -n "$DOCKERFILE_PATH" ]; then
    # Project-specific build from current directory
    if ! docker build -f "$DOCKERFILE_PATH" -t "$IMAGE_NAME" --label "dockerfile.hash=$dockerfile_hash" .; then
      echo "${RED}Error: Failed to build Docker image.${BLACK}"
      return 1
    fi
  else
    # Default build from devbox repo directory
    SCRIPT_PATH="$0"
    while [ -L "$SCRIPT_PATH" ]; do
      SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
    done
    SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

    if ! docker build -f "$SCRIPT_DIR/Dockerfile.devbox" -t "$IMAGE_NAME" --label "dockerfile.hash=$dockerfile_hash" "$SCRIPT_DIR"; then
      echo "${RED}Error: Failed to build Docker image.${BLACK}"
      return 1
    fi
  fi

  echo "✅ Successfully built $IMAGE_NAME image."
  return 0
}

# Function to check if Dockerfile exists and image is built/current
check_dockerfile_and_image() {
  local dockerfile_path
  dockerfile_path=$(get_dockerfile_path)

  if [ -n "$DOCKERFILE_PATH" ]; then
    # Project-specific container: check for local Dockerfile
    if [ ! -f "$DOCKERFILE_PATH" ]; then
      echo "${RED}Error: No $DOCKERFILE_PATH found in current directory.${BLACK}"
      echo "Run 'devbox init' to create a Dockerfile.devbox from template."
      return 1
    fi
  else
    # Default container: check for devbox Dockerfile in script directory
    if [ ! -f "$dockerfile_path" ]; then
      echo "${RED}Error: Default Dockerfile.devbox not found at $dockerfile_path${BLACK}"
      echo "Please ensure devbox is properly installed."
      return 1
    fi
  fi

  # Check if image exists and is current
  if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
    echo "Docker image '$IMAGE_NAME' not found. Building image..."
    build_image
  elif needs_rebuild; then
    echo "Dockerfile has been modified. Rebuilding image..."
    build_image
  fi

  return 0
}


# Function to attach to the devbox container
attach_devbox() {
  # Check prerequisites and dockerfile/image before attaching
  if ! check_prerequisites; then
    return 1
  fi

  if ! check_dockerfile_and_image; then
    return 1
  fi

  # Auto-start container if it exists but is stopped
  if docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
    if [ "$(docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME")" = "false" ]; then
      echo "Starting stopped container $CONTAINER_NAME..."
      docker start "$CONTAINER_NAME"
    fi
  else
    # Create and start new container if it doesn't exist
    echo "Creating new container $CONTAINER_NAME..."
    PORT=${PORT:-3000}
    docker run -d -p "$PORT:$PORT" -e "PORT=$PORT" --name "$CONTAINER_NAME" -v "$PWD":/"$PROJECT_NAME" "$IMAGE_NAME" tail -f /dev/null
  fi

  docker exec -it -w "/$PROJECT_NAME" "$CONTAINER_NAME" /bin/zsh
}

# Function to initialize a new devbox project
init_devbox() {
  if [ -f "Dockerfile.devbox" ]; then
    echo "Dockerfile.devbox already exists in current directory."
    echo "Remove it first if you want to reinitialize."
    return 1
  fi

  # Get the directory of the devbox script (resolve symlinks)
  SCRIPT_PATH="$0"
  while [ -L "$SCRIPT_PATH" ]; do
    SCRIPT_PATH="$(readlink "$SCRIPT_PATH")"
  done
  SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"

  if [ -f "$SCRIPT_DIR/Dockerfile.devbox" ]; then
    cp "$SCRIPT_DIR/Dockerfile.devbox" "./Dockerfile.devbox"
    echo "Created Dockerfile.devbox from template in current directory."
    echo "Edit the Dockerfile.devbox to customize tools for your project."
    echo "This project will now use container: devbox-$PROJECT_NAME"
  else
    echo "${RED}Error: Dockerfile.devbox not found in devbox installation directory.${BLACK}"
    echo "Please ensure devbox is properly installed."
    return 1
  fi
}

# Function to cleanup old devbox containers and images
cleanup_devbox() {
  echo "Cleaning up devbox containers and images older than 30 days..."

  # Find and remove old containers (both running and stopped)
  OLD_CONTAINERS=$(docker ps -a --filter "ancestor=devbox" --format "{{.Names}} {{.CreatedAt}}" | while read name created; do
    # Convert created date to seconds since epoch
    created_seconds=$(date -j -f "%Y-%m-%d %H:%M:%S" "$created" "+%s" 2>/dev/null || echo "0")
    current_seconds=$(date "+%s")
    age_days=$(( (current_seconds - created_seconds) / 86400 ))

    if [ "$age_days" -gt 30 ]; then
      echo "$name"
    fi
  done)

  if [ -n "$OLD_CONTAINERS" ]; then
    echo "Found old containers to remove:"
    echo "$OLD_CONTAINERS"
    printf "Remove these containers? (y/N): "
    read -r response
    case "$response" in
      [yY][eE][sS]|[yY])
        echo "$OLD_CONTAINERS" | while read container; do
          if [ -n "$container" ]; then
            echo "Removing container: $container"
            docker stop "$container" 2>/dev/null || true
            docker rm "$container" 2>/dev/null || true
          fi
        done
        ;;
      *)
        echo "Skipping container cleanup."
        ;;
    esac
  else
    echo "No old containers found."
  fi

  # Find and remove old devbox images
  OLD_IMAGES=$(docker images --filter "reference=devbox" --format "{{.Repository}}:{{.Tag}} {{.CreatedAt}}" | while read image created; do
    created_seconds=$(date -j -f "%Y-%m-%d %H:%M:%S" "$created" "+%s" 2>/dev/null || echo "0")
    current_seconds=$(date "+%s")
    age_days=$(( (current_seconds - created_seconds) / 86400 ))

    if [ "$age_days" -gt 30 ]; then
      echo "$image"
    fi
  done)

  if [ -n "$OLD_IMAGES" ]; then
    echo "Found old images to remove:"
    echo "$OLD_IMAGES"
    printf "Remove these images? (y/N): "
    read -r response
    case "$response" in
      [yY][eE][sS]|[yY])
        echo "$OLD_IMAGES" | while read image; do
          if [ -n "$image" ]; then
            echo "Removing image: $image"
            docker rmi "$image" 2>/dev/null || true
          fi
        done
        ;;
      *)
        echo "Skipping image cleanup."
        ;;
    esac
  else
    echo "No old images found."
  fi

  # Clean up dangling images
  echo "Cleaning up dangling images..."
  docker image prune -f

  echo "Cleanup complete."
}

# Function to show status of the devbox image and container
show_status() {
  local dockerfile_path
  dockerfile_path=$(get_dockerfile_path)

  echo "$PROJECT_NAME"
  printf "  Dockerfile: %s\n" "$dockerfile_path"

  # Check if image exists and determine status
  if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
    printf "  Image:       %s " "$IMAGE_NAME"
    printf "${YELLOW}[NOT BUILT]${BLACK}\n"
  else
    printf "  Image:       %s " "$IMAGE_NAME"
    # Check if rebuild is needed
    if needs_rebuild; then
      printf "${YELLOW}[REBUILD NEEDED]${BLACK}\n"
    else
      printf "${GREEN}[UP TO DATE]${BLACK}\n"
    fi
  fi

  # Check container status
  printf "  Container:   %s " "$CONTAINER_NAME"
  if docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
    if [ "$(docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME" 2>/dev/null)" = "true" ]; then
      printf "${GREEN}[RUNNING]${BLACK}\n"
    else
      printf "${YELLOW}[STOPPED]${BLACK}\n"
    fi
  else
    printf "${YELLOW}[NOT CREATED]${BLACK}\n"
  fi
}

# Function to build/rebuild the devbox image
build_devbox() {
  if ! check_prerequisites; then
    return 1
  fi

  local dockerfile_path
  dockerfile_path=$(get_dockerfile_path)

  if [ ! -f "$dockerfile_path" ]; then
    echo "${RED}Error: Dockerfile not found at $dockerfile_path${BLACK}"
    if [ -z "$DOCKERFILE_PATH" ]; then
      echo "Run 'devbox init' to create a project-specific Dockerfile.devbox"
    fi
    return 1
  fi

  build_image
}

# Function to delete the devbox image
delete_devbox() {
  if ! check_prerequisites; then
    return 1
  fi

  # Check if image exists
  if ! docker image inspect "$IMAGE_NAME" >/dev/null 2>&1; then
    echo "Docker image '$IMAGE_NAME' does not exist."
    return 0
  fi

  # Check if any containers are using this image
  CONTAINERS_USING_IMAGE=$(docker ps -a --filter "ancestor=$IMAGE_NAME" --format "{{.Names}}" | tr '\n' ' ')

  if [ -n "$CONTAINERS_USING_IMAGE" ]; then
    echo "The following containers are using image '$IMAGE_NAME':"
    echo "$CONTAINERS_USING_IMAGE"
    printf "Stop and remove these containers before deleting the image? (y/N): "
    read -r response
    case "$response" in
      [yY][eE][sS]|[yY])
        for container in $CONTAINERS_USING_IMAGE; do
          echo "Stopping and removing container: $container"
          docker stop "$container" 2>/dev/null || true
          docker rm "$container" 2>/dev/null || true
        done
        ;;
      *)
        echo "Cannot delete image while containers are using it."
        return 1
        ;;
    esac
  fi

  echo "Deleting Docker image '$IMAGE_NAME'..."
  if docker rmi "$IMAGE_NAME" 2>/dev/null; then
    echo "✅ Successfully deleted image '$IMAGE_NAME'"
  else
    echo "${RED}Error: Failed to delete image '$IMAGE_NAME'${BLACK}"
    return 1
  fi
}

# Check the command argument
case "$1" in
  init)
    init_devbox
    ;;
  cleanup)
    cleanup_devbox
    ;;
  status)
    show_status
    ;;
  build)
    build_devbox
    ;;
  delete)
    delete_devbox
    ;;
  start)
    # Explicitly start container (existing functionality)
    if ! check_prerequisites; then
      exit 1
    fi

    if ! check_dockerfile_and_image; then
      exit 1
    fi

    if docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
      if [ "$(docker inspect -f '{{.State.Running}}' "$CONTAINER_NAME")" = "false" ]; then
        echo "Starting stopped container $CONTAINER_NAME..."
        docker start "$CONTAINER_NAME"
      else
        echo "Container $CONTAINER_NAME is already running."
      fi
    else
      echo "Creating new container $CONTAINER_NAME..."
      PORT=${PORT:-3000}
      docker run -d -p "$PORT:$PORT" -e "PORT=$PORT" --name "$CONTAINER_NAME" -v "$PWD":/"$PROJECT_NAME" "$IMAGE_NAME" tail -f /dev/null
    fi
    ;;
  stop)
    # Stop container without removing
    if docker ps --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
      echo "Stopping container $CONTAINER_NAME..."
      # Stop immediately without waiting.
      docker stop -t 0 "$CONTAINER_NAME"
    else
      echo "Container $CONTAINER_NAME is not running."
    fi
    ;;
  destroy)
    # Stop and remove container
    if docker ps -a --format '{{.Names}}' | grep -q "^$CONTAINER_NAME$"; then
      echo "Destroying container $CONTAINER_NAME..."
      docker stop "$CONTAINER_NAME" 2>/dev/null || true
      docker rm "$CONTAINER_NAME"
    else
      echo "Container $CONTAINER_NAME does not exist."
    fi
    ;;
  "")
    attach_devbox
    ;;
  *)
    echo "Usage: $0 {list|init|cleanup|path|status|build|delete|start|stop|destroy}"
    echo "       $0               # attach to devbox (default)"
    echo ""
    echo "Commands:"
    echo "  (no args)  - Attach to or create devbox container for this directory"
    echo "  init       - Copy Dockerfile.devbox template to current directory"
    echo "  cleanup    - Remove old devbox containers and images"
    echo ""
    echo "New commands:"
    echo "  status     - Show status of devbox image and container"
    echo "  build      - Build/rebuild the devbox image"
    echo "  delete     - Delete the devbox image (stops containers first)"
    echo ""
    echo "Container management:"
    echo "  start      - Start container (create if doesn't exist)"
    echo "  stop       - Stop container without removing"
    echo "  destroy    - Stop and remove container"
    ;;
esac
